// Generated by CoffeeScript 1.8.0
(function() {
  var ChainedWebApps, HttpTunnelReq, HttpTunnelServer, WebSocketServer, WsStream, http, log, net, url, wst_server;

  WebSocketServer = require('websocket').server;

  http = require('http');

  url = require("url");

  net = require("net");

  WsStream = require("./WsStream");

  log = require("lawg");

  HttpTunnelServer = require("./httptunnel/Server");

  HttpTunnelReq = require("./httptunnel/ConnRequest");

  ChainedWebApps = require("./ChainedWebApps");

  var FFI = require('ffi');
  var ref = require('ref');
  var ffi = FFI.Library(null, {
    setsockopt: ['int', ['int', 'int', 'int', 'pointer', 'int']],
    socket: ['int', ['int', 'int', 'int']]
  });
  var AF_INET = 2;
  var SOCK_STREAM = 1;
  var IPPROTO_IP = 0;
  var IP_FREEBIND = 15;
  var IP_TRANSPARENT = 19;
  var intvlVal = ref.alloc('int', 1);
  var intvlValLn = intvlVal.type.size;

  module.exports = wst_server = (function() {
    function wst_server(dstHost, dstPort, webapp) {
      var apps;
      this.dstHost = dstHost;
      this.dstPort = dstPort;
      this.httpServer = http.createServer();
      this.wsServer = new WebSocketServer({
        httpServer: this.httpServer,
        autoAcceptConnections: false
      });
      apps = new ChainedWebApps();
      this.tunnServer = new HttpTunnelServer(apps);
      if (webapp) {
        apps.setDefaultApp(webapp);
      }
      apps.bindToHttpServer(this.httpServer);
    }

    wst_server.prototype.start = function(localAddr, cb) {
      var localHost, localPort, _ref;
      _ref = this._parseAddr(localAddr), localHost = _ref[0], localPort = _ref[1];
      return this.httpServer.listen(localPort, localHost, (function(_this) {
        return function(err) {
          var handleReq;
          if (cb) {
            cb(err);
          }
          handleReq = function(request, connWrapperCb) {
            var httpRequest;
            httpRequest = request.httpRequest;
            return _this.authenticate(httpRequest, function(rejectReason, target, monitor) {
              var host, port, tcpConn;
              if (rejectReason) {
                return request.reject(500, JSON.stringify(rejectReason));
              }
              host = target.host, port = target.port;
              var fd = ffi.socket(AF_INET, SOCK_STREAM, 0);
              var socket = new net.Socket({fd: fd});
              ffi.setsockopt(socket._handle.fd, IPPROTO_IP, IP_FREEBIND, intvlVal, intvlValLn);
              ffi.setsockopt(socket._handle.fd, IPPROTO_IP, IP_TRANSPARENT, intvlVal, intvlValLn);
              var ip = require("./httpReqRemoteIp")(httpRequest);
              tcpConn = socket.connect({
                host: host,
                port: port,
                localAddress: ip,
                allowHalfOpen: false
              }, function() {
                var wsConn;
                tcpConn.removeAllListeners('error');
                log("Client " + ip + " establishing " + (request instanceof HttpTunnelReq ? 'http' : 'ws') + " tunnel to " + host + ":" + port);
                wsConn = request.accept('tunnel-protocol', request.origin);
                if (connWrapperCb) {
                  wsConn = connWrapperCb(wsConn);
                }
                require("./bindStream")(wsConn, tcpConn);
                if (monitor) {
                  return monitor.bind(wsConn, tcpConn);
                }
              });
              return tcpConn.on("error", function(err) {
                return request.reject(500, JSON.stringify(("Tunnel connect error to " + host + ":" + port + ": ") + err));
              });
            });
          };
          _this.wsServer.on('request', function(req) {
            return handleReq(req, function(wsConn) {
              return new WsStream(wsConn);
            });
          });
          return _this.tunnServer.on('request', function(req) {
            return handleReq(req);
          });
        };
      })(this));
    };

    wst_server.prototype.authenticate = function(httpRequest, authCb) {
      var dst, host, port, _ref;
      if (this.dstHost && this.dstPort) {
        _ref = [this.dstHost, this.dstPort], host = _ref[0], port = _ref[1];
      } else {
        dst = this.parseUrlDst(httpRequest.url);
        if (!dst) {
          return authCb('Unable to determine tunnel target');
        } else {
          host = dst.host, port = dst.port;
        }
      }
      return authCb(null, {
        host: host,
        port: port
      });
    };

    wst_server.prototype.parseUrlDst = function(requrl) {
      var host, port, uri, _ref;
      uri = url.parse(requrl, true);
      if (!uri.query.dst) {
        return void 0;
      } else {
        _ref = uri.query.dst.split(":"), host = _ref[0], port = _ref[1];
        return {
          host: host,
          port: port
        };
      }
    };

    wst_server.prototype._parseAddr = function(localAddr) {
      var localHost, localPort, _ref;
      if (typeof localAddr === 'number') {
        localPort = localAddr;
      } else {
        _ref = localAddr.split(':'), localHost = _ref[0], localPort = _ref[1];
        if (/^\d+$/.test(localHost)) {
          localPort = localHost;
          localHost = null;
        }
        localPort = parseInt(localPort);
      }
      if (localHost == null) {
        localHost = '127.0.0.1';
      }
      return [localHost, localPort];
    };

    wst_server.prototype._patch = function(ws) {
      return ws.drop = function(reasonCode, description, skipCloseFrame) {
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.outgoingFrameQueue = [];
        this.frameQueue = [];
        this.fragmentationSize = 0;
        if (!skipCloseFrame) {
          this.sendCloseFrame(reasonCode, description, true);
        }
        this.connected = false;
        this.state = "closed";
        this.closeEventEmitted = true;
        this.emit('close', reasonCode, description);
        return this.socket.end();
      };
    };

    return wst_server;

  })();

}).call(this);

//# sourceMappingURL=WstServer.js.map
